# -*- coding: utf-8 -*-
"""NHOM20.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1kPd2abvSFtik7L9yUvDOH2nELvnvzvsj
"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# %cd /content/drive/MyDrive/PTDLL

"""#Triển khai dư liệu"""

import pandas as pd
import numpy as np
from pathlib import Path

path=Path('/content/drive/MyDrive/PTDLL/Raw_Data/exp_data_dongda.xlsx')
if path.is_file():
  print('File exists')
else:
  print('File not exists')

df=pd.read_excel(path)
df.head(20)

df.columns

# Kiểm tra giá trị null
print(df.isnull().sum())

# Kiểm tra giá trị bị thiếu
print(df.isna().sum())

# Kiểm tra tỷ lệ phần trăm giá trị bị thiếu cho mỗi cột
print(df.isnull().sum() / len(df) * 100)

df.info()

"""#Tien Xu Ly"""

import matplotlib.pyplot as plt
import seaborn as sns

#Lấy các cột có kiểu số kèm theo cột "Location"
df_filtered=df.select_dtypes(include=['float64']).copy()
try:
  df_filtered[['location']]=df[['location']]
except:
  print('Da xay ra loi ')

df_filtered.head(10)

#Loai bo cac cot khong can thiet
df_filtered.drop(columns=['coordinates','province_code','sub_district_code','prd_number'],inplace=True)
df_filtered.head(10)

ID=[i for i in range(1,len(df_filtered)+1)]
df_filtered['ID']=ID

df_filtered.set_index('ID',inplace=True)
df_filtered.head(10)

#Loại bỏ các cột không chứa thông tin giá nhà
df_filtered.dropna(subset=['conversion_price'],inplace=True)
df_filtered.info()

numeric_columns=df_filtered.select_dtypes(include=['float64']).columns
numeric_columns

# Thiết lập một figure duy nhất để chứa các biểu đồ
plt.figure(figsize=(16, 10))

# Lặp qua từng cột và tạo boxplot
for i, column in enumerate(df_filtered[numeric_columns].columns, 1):
    plt.subplot(2, (len(numeric_columns) + 1) // 2, i)  # Tùy chỉnh layout tự động
    sns.boxplot(y=df_filtered[numeric_columns][column])
    plt.title(f'Box Plot của {column}')
    plt.ylabel(column)

# Điều chỉnh layout và hiển thị
plt.tight_layout()
plt.show()

#=> Giá nhà này có sự sai lệch rất lớn, không đáng tin ==> Lọc lại giá nhà
#=> Diện tích cũng có sự sai lệch lớn
#=> Các cái còn lại cũng cần điều chỉnh

# Đặt ngưỡng dựa trên Q1,Q3và IQR
Q1 = df_filtered[numeric_columns].quantile(0.25)
Q3= df_filtered[numeric_columns].quantile(0.75)
IQR = Q3 - Q1
downer_threshold = Q1- 0.5*IQR
upper_threshold= Q3 + 1* IQR

print(downer_threshold)
print(upper_threshold)

#đặt lại ngưỡng của giá nhà va dien tich
Q1_price = df_filtered['conversion_price'].quantile(0.25)
Q3_price = df_filtered['conversion_price'].quantile(0.75)
IQR_price = Q3_price - Q1_price

downer_threshold_price = df_filtered['conversion_price'].quantile(0.22)
upper_threshold_price= df_filtered['conversion_price'].quantile(0.75)
downer_threshold['conversion_price']=downer_threshold_price
upper_threshold['conversion_price']=upper_threshold_price

downer_threshold_area=20
upper_threshold_area=95
downer_threshold['area']=downer_threshold_area
upper_threshold['area']=upper_threshold_area

print(downer_threshold)
print(upper_threshold)

#Tiến hành lọc lại
df1_filtered=df_filtered.copy()
for column in numeric_columns:
  df1_filtered=df1_filtered[(df1_filtered[column]>=downer_threshold[column]) & (df1_filtered[column]<=upper_threshold[column])]

import matplotlib.pyplot as plt
import seaborn as sns

# Thiết lập phong cách của Seaborn
sns.set_theme(style="whitegrid", palette="pastel")

# Thiết lập một figure duy nhất để chứa các biểu đồ
plt.figure(figsize=(18, 8))

# Các cột cần tạo boxplot
columns = ['bed_room_num', 'toilet_room_num', 'floor_num']

# Lặp qua từng cột và tạo boxplot
for idx, column in enumerate(columns, 1):  # Bắt đầu đếm từ 1
    plt.subplot(1, 3, idx)  # Chia layout thành 1 hàng và 3 cột
    sns.boxplot(x=column, y='conversion_price', data=df1_filtered, palette="Blues", linewidth=1.5)

    # Trang trí
    plt.title(f'Box Plot của {column}', fontsize=14, fontweight='bold', color='navy')
    plt.xlabel(column, fontsize=12, fontweight='bold', color='darkblue')
    plt.ylabel('Conversion Price', fontsize=12, fontweight='bold', color='darkblue')

    # Format trục y (hiển thị giá trị bằng đơn vị 'k' để dễ đọc)
    plt.yticks(fontsize=10)
    plt.xticks(fontsize=10)
    plt.grid(axis='y', linestyle='--', alpha=0.7)

# Thêm tiêu đề tổng thể
plt.suptitle("So sánh Conversion Price qua các yếu tố", fontsize=16, fontweight='bold', color='darkgreen')

plt.tight_layout(rect=[0, 0, 1, 0.95])  # Căn chỉnh tổng thể
plt.show()

#tiến hành lọc lại một số dữ liệu
# Điều kiện giữ lại: Các dòng không phải là 2 phòng ngủ hoặc giá <= 8 tỷ
df1_filtered = df1_filtered[~((df1_filtered['bed_room_num'] == 2) & (df1_filtered['conversion_price'] > 8000))]
df1_filtered = df1_filtered[~((df1_filtered['bed_room_num'] == 3) & (df1_filtered['conversion_price'] > 12000))]
df1_filtered = df1_filtered[~((df1_filtered['toilet_room_num'] == 2) & (df1_filtered['conversion_price'] > 10000))]
df1_filtered = df1_filtered[~((df1_filtered['toilet_room_num'] == 5) & (df1_filtered['conversion_price'] < 2500))]
df1_filtered = df1_filtered[~((df1_filtered['floor_num'] ==6) & (df1_filtered['conversion_price'] < 3500))]
df1_filtered = df1_filtered[~((df1_filtered['floor_num'] == 7) & (df1_filtered['conversion_price'] < 4000))]

# Kiểm tra lại kết quả
print(df1_filtered.head())
print(f"Số lượng dòng sau khi lọc: {len(df1_filtered)}")

# Thiết lập một figure duy nhất để chứa các biểu đồ
plt.figure(figsize=(16, 10))

# Lặp qua từng cột và tạo boxplot
for i, column in enumerate(df1_filtered[numeric_columns].columns, 1):
    plt.subplot(2, (len(numeric_columns) + 1) // 2, i)  # Tùy chỉnh layout tự động
    sns.boxplot(y=df1_filtered[numeric_columns][column])
    plt.title(f'Box Plot của {column}')
    plt.ylabel(column)

# Điều chỉnh layout và hiển thị
plt.tight_layout()
plt.show()

df1_filtered.info()

import matplotlib.pyplot as plt
import seaborn as sns
import pandas as pd
import numpy as np

numeric_columns = df1_filtered.select_dtypes(include=['float64', 'int64']).columns


area_bins = np.arange(20, 100, 10)  # Bins for 'area' from 20 to 100 with a step of 10
price_bins = np.arange(0, 15000, 1000)  # Bins for 'conversion_price' from 0 to 15000 with a step of 1000

plt.figure(figsize=(25, 15))

for i, col in enumerate(numeric_columns):
    plt.subplot(len(numeric_columns) // 3 + 1, 3, i + 1)

    if col == 'area':
        # Create bins for 'area'
        df1_filtered['area_bins'] = pd.cut(df1_filtered['area'], bins=area_bins, include_lowest=True)
        sns.countplot(x='area_bins', data=df1_filtered)
        plt.xlabel('Area Range')
        plt.xticks(rotation=45, ha='right')
    elif col == 'conversion_price':
        # Create bins for 'conversion_price'
        df1_filtered['price_bins'] = pd.cut(df1_filtered['conversion_price'], bins=price_bins, include_lowest=True)
        sns.countplot(x='price_bins', data=df1_filtered)
        plt.xlabel('Price Range')
        plt.xticks(rotation=45, ha='right')
    else:
        # Plot other numeric columns as before
        sns.countplot(x=col, data=df1_filtered)
        plt.xticks(rotation=45, ha='right')

    plt.title(f'Bar Plot of {col}')

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt

# Assuming df1_filtered is your DataFrame after all the processing
numeric_columns = df1_filtered.select_dtypes(include=['float64', 'int64']).columns

plt.figure(figsize=(15, 10))

for i, col in enumerate(numeric_columns):
    plt.subplot(len(numeric_columns) // 3 + 1, 3, i + 1)
    plt.scatter(df1_filtered[col], df1_filtered['conversion_price'])
    plt.xlabel(col)
    plt.ylabel('conversion_price')
    plt.title(f'Scatter Plot of {col} vs. conversion_price')

plt.tight_layout()
plt.show()

df1_filtered.describe()

#Map lại địa điểm

#Trích xuất tên phường từ cột 'location'
df1_filtered['Phường'] = df1_filtered['location'].str.extract(r'Phường\s+(.+?)(?:,\s|$)', expand=False)

df1_filtered['Phường'].unique()

df1_filtered.info()

cleaned_wards = [
    'Láng Thượng', 'Láng Hạ', 'Phương Mai', 'Cát Linh',
    'Nam Đồng', 'Thịnh Quang', 'Kim Liên', 'Khương Thượng',
    'Ô Chợ Dừa', 'Hàng Bột', 'Trung Liệt', 'Trung Phụng',
    'Thổ Quan', 'Văn Chương', 'Quốc Tử Giám', 'Ngã Tư Sở',
    'Quang Trung', 'Trung Tự', 'Phương Liên', 'Khâm Thiên',
    'Văn Miếu'
]

wards_dict = {
    "Láng Thượng": ["Láng Thượng", "Láng Thượng"],
    "Láng Hạ": ["Láng Hạ", "Láng Hạ"],
    "Phương Mai": ["Phương Mai"],
    "Cát Linh": ["Cát Linh", "Cát Linh"],
    "Nam Đồng": ["Nam Đồng", "Nam Đồng"],
    "Thịnh Quang": ["Thịnh Quang", "Thịnh Quang"],
    "Kim Liên": ["Kim Liên"],
    "Khương Thượng": ["Khương Thượng", "Khương Thượng", "khương Thượng"],
    "Ô Chợ Dừa": ["Ô Chợ Dừa", "Ô Chợ Dừa"],
    "Hàng Bột": ["Hàng Bột", "Hàng Bột"],
    "Trung Liệt": ["Trung Liệt", "Trung Liệt"],
    "Trung Phụng": ["Trung Phụng", "Trung Phụng"],
    "Thổ Quan": ["Thổ Quan", "Thổ Quan"],
    "Văn Chương": ["Văn Chương"],
    "Quốc Tử Giám": ["Quốc Tử Giám", "Quốc Tử Giám"],
    "Ngã Tư Sở": ["Ngã Tư Sở", "Ngã Tư Sở"],
    "Quang Trung": ["Quang Trung"],
    "Trung Tự": ["Trung Tự", "Trung Tự"],
    "Phương Liên": ["Phương Liên"],
    "Khâm Thiên": ["Khâm Thiên"],
    "Văn Miếu": ["Văn Miếu", "Văn Miếu"]
}

# Tạo từ điển đảo ngược
reversed_mapping = {}

for key, values in wards_dict.items():
    for value in values:
        reversed_mapping[value] = key

print(reversed_mapping)

df1_filtered['Phường'].replace(reversed_mapping,inplace=True)

df1_filtered['Phường'].unique()

import matplotlib.pyplot as plt
import numpy as np
import math


#Phân bố số lượng nhà theo phường

def rotate_text(text, autotext, percentage, startangle=90):
    angle = startangle + percentage/100 * 360
    angle = angle if angle < 180 else angle-360

    if (math.isclose(autotext.get_position()[0], 0.0, rel_tol=1e-09) and autotext.get_position()[1] < 0.0):
        angle -= 180

    text.set_rotation(angle)
    autotext.set_rotation(angle)


ward_counts = df1_filtered['Phường'].value_counts()


plt.figure(figsize=(15, 15))

explode = [0.05] * len(ward_counts)

# Create pie chart with adjusted label properties
wedges, texts, autotexts = plt.pie(ward_counts,
                                  labels=ward_counts.index,
                                  explode=explode,
                                  autopct='%1.1f%%',
                                  startangle=90,
                                  textprops={'fontsize': 10},
                                  pctdistance=0.85)
plt.title('Phân bố số lượng nhà theo phường', fontsize=16, y=1.08)
plt.axis('equal')

# Rotate overlapping labels
total_percentage = 0
for i in range(len(ward_counts)):
    percentage = ward_counts[i]/sum(ward_counts)*100
    rotate_text(texts[i], autotexts[i], total_percentage)
    total_percentage += percentage

plt.show()

# Bước 2: Áp dụng one-hot encoding cho cột 'ward'
one_hot_wards = pd.get_dummies(df1_filtered['Phường'], prefix='Phường')

# Bước 3: Ghép one-hot encoding vào DataFrame ban đầu
df1_filtered = pd.concat([df1_filtered, one_hot_wards], axis=1)

# Hiển thị kết quả
print(df1_filtered)

#Tính toán hệ số tương quan
# Tính toán hệ số tương quan
df1_drop=df1_filtered.drop(columns=['location','Phường'])
correlation_matrix = df1_drop.corr()

# In ra hệ số tương quan với giá nhà
correlation_with_price = correlation_matrix['conversion_price']
print(correlation_with_price)

import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt

# Tạo ma trận hệ số tương quan
correlation_matrix = df1_filtered.iloc[:,0:5].corr()

# Vẽ heatmap bằng seaborn
plt.figure(figsize=(10, 8))  # Kích thước hình ảnh
sns.heatmap(correlation_matrix,
            annot=True,  # Hiển thị giá trị hệ số tương quan trên heatmap
            cmap='coolwarm',  # Bảng màu
            fmt=".2f",  # Định dạng số (2 chữ số thập phân)
            linewidths=0.5)  # Đường phân cách giữa các ô

# Thêm tiêu đề
plt.title('Correlation Matrix Heatmap', fontsize=16)
plt.show()

"""#Tien Hanh Du Doan

"""

df1_filtered.info()
df1_filtered.drop(columns=['location','Phường'],inplace=True)

df1_cpy=df1_filtered.copy()
df1_cpy.info()

# Tách dữ liệu thành đặc trưng (X) và nhãn (y)
X = df1_cpy.drop(columns=["conversion_price"]).to_numpy()  # Chuyển các cột đặc trưng sang NumPy
y = df1_cpy["conversion_price"].to_numpy()  # Chuyển cột nhãn sang NumPy

from sklearn.linear_model import LinearRegression
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score

# Chia dữ liệu thành tập train và test
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)

# Khởi tạo và huấn luyện mô hình
model = LinearRegression()
model.fit(X_train, y_train)

# Dự đoán trên tập test
y_pred = model.predict(X_test)

pd.DataFrame({'Actual': y_test, 'Predicted': y_pred})

"""## Đánh giá kết quả dự đoán"""

from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
import numpy as np
# Tính MAE
mae = mean_absolute_error(y_test, y_pred)

# Tính RMSE
rmse = np.sqrt(mean_squared_error(y_test, y_pred))

# Tính R²
r2 = r2_score(y_test, y_pred)

print(f"Mean Absolute Error (MAE): {mae}")
print(f"Root Mean Squared Error (RMSE): {rmse}")
print(f"R-squared (R²): {r2}")
# Tính MAPE
mape = np.mean(np.abs((y_test - y_pred) / y_test)) * 100

# In kết quả
print(f"Mô hình với độ chính xác: {100 - mape}%")

"""##Tiến hành dự đoán"""



import pandas as pd
import joblib  # Or another library to load the trained model


def predict_house_price(area, bed_room_num, toilet_room_num, floor_num, ward):
    """Predicts the price of a house based on input features.

    Args:
        area: The area of the house in square meters.
        bed_room_num: The number of bedrooms.
        toilet_room_num: The number of bathrooms.
        floor_num: The number of floors.
        ward: The ward where the house is located.

    Returns:
        The predicted price of the house.
    """
    # Create a DataFrame with the input features
    input_features = pd.DataFrame({
        'area': [area],
        'bed_room_num': [bed_room_num],
        'toilet_room_num': [toilet_room_num],
        'floor_num': [floor_num],
        'ward': [ward]  # Include the ward
    })

    # One-hot encode the ward
    input_features = pd.get_dummies(input_features, columns=['ward'], prefix='Phường')

    # Ensure all ward columns are present in the input features
    ward_columns = [f'Phường_{w}' for w in cleaned_wards]
    for col in ward_columns:
        if col not in input_features.columns:
            input_features[col] = 0

    # Reorder columns to match the model's training data
    input_features = input_features[['area', 'bed_room_num', 'toilet_room_num', 'floor_num'] + ward_columns]

    # Make the prediction
    predicted_price = model.predict(input_features.to_numpy())[0]  # Get the scalar value

    return predicted_price

# Example usage
try:
    area = float(input('Enter area (m²): '))
    bed_room_num = int(input('Enter number of bedrooms: '))
    toilet_room_num = int(input('Enter number of bathrooms: '))
    floor_num = int(input('Enter number of floors: '))
    ward = input('Enter ward name: ')

    if ward not in cleaned_wards:
        raise ValueError(f"Invalid ward name. Please choose from {', '.join(cleaned_wards)}.")

    predicted_price = predict_house_price(area, bed_room_num, toilet_room_num, floor_num, ward)

    print(f'Predicted house price: {predicted_price}')
except ValueError as e:
    print(f"Error: {e}")
except Exception as e:
    print(f"An unexpected error occurred: {e}")